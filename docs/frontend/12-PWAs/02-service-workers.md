---
title: Intoduction To Service Worker
description: What is a Service Worker ,
Key Advantages of Service Worker , 
Regestration , Installation , Activation , Cashing Strategies
---

![offline-support](../images/service_worker.jpeg)

## What is Service Worker

سرویس ورکر اسکریپتی است که در پس‌زمینه یک برنامه وب، جدا از صفحه اصلی وب اجرا می‌شود و به عنوان یک پروکسی بین برنامه وب، مرورگر و شبکه عمل می‌کند. این ویژگی‌های پیشرفته مختلف را برای برنامه‌های وب فعال می‌کند، از جمله دسترسی آفلاین، همگام‌سازی پس‌زمینه، و پوش نوتیفیکیشن ها. سرویس ورکر  بخش اساسی معماری برنامه وب پیشرو (PWA) هستند.


در اینجا برخی از ویژگی ها و قابلیت های کلیدی سرویس ورکر ها آورده شده است:

- پردازش پس‌زمینه (Background Processing) 
- ذخیره سازی ( Caching) 
- دسترسی آفلاین ( Offline Access) 
-  Network Intercept
- پوش نوتیفیکیشن ها (Push Notifications) 
- همگام سازی پس زمینه ( Background Sync) 
- امنیت (Security ) 
- چرخه حیات و به روز رسانی ( Lifecycle and Updating) 


## Registration

ثبت یک سرویس ورکر شامل این است که به مرورگر بگویید که یک فایل جاوا اسکریپت خاص را با چرخه عمر سرویس ورکر مرتبط کند. این فرآیند ثبت‌نام به سرویس ورکر اجازه می‌دهد تا صفحات وب را در محدوده خود کنترل کند و درخواست‌های شبکه را رهگیری کند و قابلیت ذخیره‌سازی و عملکرد آفلاین را فعال کند. در اینجا نحوه ثبت یک سرویس ورکر در برنامه وب خود توضیح داده شده است :

۱- ایجاد فایل Service Worker: با ایجاد یک فایل جاوا اسکریپت جداگانه برای سرویس ورکر خود شروع کنید. این فایل حاوی منطق ذخیره‌سازی، رهگیری درخواست‌های شبکه و مدیریت event  های چرخه حیات سرویس ورکر است.

```javascript 
// sw.js

// Your service worker code here  
```

۲- ثبت نام Service Worker : در فایل اصلی جاوا اسکریپت خود (معمولاً جایی که برنامه خود را راه اندازی می کنید)، می توانید با استفاده از متد ()navigator.serviceWorker.register سرویس ورکر را ثبت کنید.


```javascript 
// main.js

if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/sw.js')
    .then((registration) => {
      console.log('Service Worker registered with scope:', registration.scope);
    })
    .catch((error) => {
      console.error('Service Worker registration failed:', error);
    });
}
```

در این مثال، از متد navigator.serviceWorker.register() برای ثبت فایل sw.js استفاده شده است. این یک promise را برمی گرداند که به یک شی ServiceWorkerRegistration resolve می شود.

- اسکوپ service worker :محدوده یک Service Worker تعیین می کند که چه صفحاتی را می تواند کنترل کند. به طور پیش فرض، scope  دایرکتوری است که سرویس ورکر در آن قرار دارد. به عنوان مثال، اگر /sw.js را ثبت کنید، محدوده دایرکتوری روت خواهد بود. شما می توانید صفحات را در آن محدوده و زیر شاخه های آن کنترل کنید.

- چرخه حیات سرویس ورکر : پس از ثبت نام، سرویس ورکر یک چرخه حیاتی را طی می‌کند که شامل نصب، فعال‌سازی و fetch کردن  event ها می‌شود. می‌توانید این event ها را در اسکریپت Service Worker خود listen کنید و حافظه پنهان و سایر قابلیت‌ها را پیاده‌سازی کنید.

```javascript
//sw.js

self.addEventListener('install', (event) => {
  // Caching logic during installation
});

self.addEventListener('activate', (event) => {
  // Cleanup and cache management after activation
});

self.addEventListener('fetch', (event) => {
  // Network interception and caching strategies
}); 
```

با ثبت نام یک سرویس‌ ورکر، ویژگی‌های پیشرفته‌ای مانند دسترسی آفلاین، حافظه پنهان و همگام‌سازی پس‌زمینه را در برنامه وب خود فعال می‌کنید. مدیریت به‌روزرسانی‌های سرویس‌ ورکر، همانطور که در پاسخ‌های قبلی ذکر شد، ضروری است تا مطمئن شوید کاربران همیشه با آخرین نسخه برنامه شما کار می‌کنند.


## Installation

1-ریجستر کردن سزویس ورکر

2- ایونت Install : هنگامی که سرویس‌ ورکر ثبت شد، مرورگر event نصب را راه‌اندازی می‌کند. می توانید با استفاده از روش self.addEventListener('install', ...)  این event را در اسکریپت Service Worker خود  listen کنید :

```javascript
// sw.js

self.addEventListener('install', (event) => {
  event.waitUntil(
    // Perform caching and other setup tasks here
  );
});
```

3- منابع Cash شده : در طول  رویداد install می توانید از متد event.waitUntil برای تمدید فرآیند نصب تا زمانی که promise مشخص شده resolve شود استفاده کنید. این معمولاً برای ذخیره منابع ضروری برای اطمینان از عملکرد آفلاین یا در شرایط اینترنت ضعیف استفاده می شود.

```javascript
4.	// sw.js
5.	
6.	self.addEventListener('install', (event) => {
7.	  event.waitUntil(
8.	    caches.open('my-cache').then((cache) => {
9.	      return cache.addAll([
10.	        '/index.html',
11.	        '/styles.css',
12.	        '/app.js',
13.	        // Add more files to cache
14.	      ]);
15.	    })
16.	  );
17.	}); 
```

4-Skip Waiting : به طور پیش‌فرض، وقتی یک سرویس ورکر جدید نصب می‌شود، منتظر می‌ماند تا هر سرویس‌ ورکر فعال موجود قبل از اینکه کنترل را به دست بگیرد، بیکار شود. برای رد شدن از این انتظار و فعال کردن فوری سرویس‌ک ورکر جدید، می‌توانید از روش ()self.skipWaiting استفاده کنید. این می تواند برای اطمینان از اینکه کاربران آخرین نسخه برنامه شما را فوراً دریافت می کنند مفید باشد.

```javascript
// sw.js

self.addEventListener('install', (event) => {
  event.waitUntil(
    // Caching logic
  );
  self.skipWaiting(); // Skip the waiting phase and activate immediately
}); 
```

## Activation

فعال‌سازی سرویس ورکر مرحله‌ای حیاتی در چرخه حیات یک سرویس ورکر است. هنگامی که یک سرویس ورکر نصب می‌شود، بلافاصله کنترل صفحات و منابع را در دست نمی‌گیرد. در عوض، آن را از طریق یک فرآیند فعال سازی می گذراند که به آن اجازه می دهد تا شروع به کنترل مشتریان (صفحات وب) و انجام کارهای پاکسازی یا مهاجرت کند. در اینجا آنچه شما باید در مورد فعال سازی سرویس ورکر بدانید آمده است :

1- ایونت avtivate : هنگامی که یک سرویس‌ ورکر نصب می‌شود و صفحات وب مرتبط با آن بسته می‌شوند یا دوباره بارگیری می‌شوند، مرورگر منتظر می‌ماند تا دیگر صفحه‌ای وجود نداشته باشد که سرویس‌ ورکر آن را کنترل می‌کند. پس از این اتفاق، سرویس‌ ورکر فعال می‌شود و رویداد فعال‌سازی اجرا می‌شود.

2- پاک کردن کش های قدیمی: یکی از کارهای رایج در طول فعال سازی، پاک کردن کش های قدیمی از نسخه های قبلی سرویس ورکر یا برنامه است. می توانید نام های کش را با هم مقایسه کنید و کش هایی را که دیگر مورد نیاز نیستند حذف کنید.

```javascript

// sw.js

self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== 'current-cache') {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
}); 
``` 

3- Skip Waiting :  اگر می‌خواهید که سرویس‌ورکر جدید بلافاصله پس از فعال‌سازی کنترل را در دست بگیرد، می‌توانید از روش ()self.skipWaiting استفاده کنید. این می تواند برای اطمینان از اینکه کاربران آخرین نسخه برنامه شما را بدون نیاز به بارگیری مجدد چندین بار دریافت می کنند مفید باشد.

```javascript
// sw.js
	
self.addEventListener('activate', (event) => {
event.waitUntil(
	    // Cleanup tasks
);
self.skipWaiting(); // Activate immediately and take control
});
```
4- Client Claim : به طور پیش فرض، سرویس ورکر جدید فقط کلاینت های جدیدی (صفحات وب) را که پس از فعال سازی باز می شوند کنترل می کند. برای اینکه سرویس‌ورکر جدید کنترل همه کلاینت‌های باز را به دست بگیرد، می‌توانید از روش self.clients.claim() استفاده کنید.

```javascript
// sw.js

self.addEventListener('activate', (event) => {
  event.waitUntil(
    // Cleanup tasks
    self.clients.claim(); // Take control of all open clients
  );
});
```


## Cashing Strategies

### Cash-First Strategy

در استراتژی Cache-First، سرویس‌ورکر ابتدا بررسی می‌کند که آیا منبع درخواستی در حافظه پنهان موجود است یا خیر. اگر اینطور باشد، نسخه کش ارائه می شود. در غیر این صورت، سرویس‌کار منبع را از شبکه fetch می‌کند و آن را برای استفاده بعدی ذخیره می‌کند.

```javascript
// Service Worker Script (sw.js)

self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open('my-cache').then((cache) => {
      return cache.addAll([
        '/index.html',
        '/styles.css',
        '/app.js',
        // Add more files to cache
      ]);
    })
  );
});

self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request).then((response) => {
      return response || fetch(event.request);
    })
  );
});
```

در این مثال :
در رویداد  install، یک کش به نام my-cache را باز می کنیم و منابعی را به آن اضافه می کنیم.
در رویداد fetch، درخواست های شبکه را رهگیری می کنیم و بررسی می کنیم که آیا منبع درخواستی در حافظه پنهان است یا خیر. در صورت وجود، ما آن را از حافظه پنهان لود می کنیم. در غیر این صورت، آن را از شبکه دریافت می کنیم.


### Network-First Strategy

در استراتژی  Network-First ، سرویس‌ورکر ابتدا سعی می‌کند منبع درخواستی را از شبکه دریافت کند. اگر درخواست شبکه (آفلاین) ناموفق باشد، سرویس‌ورکر محتوا را از حافظه پنهان ارائه می‌کند.

```javascript
//Script (sw.js)
self.addEventListener('fetch', (event) => {
  event.respondWith(
    fetch(event.request)
      .then((response) => {
        // Clone the response to cache it
        const clonedResponse = response.clone();
        caches.open('my-cache').then((cache) => {
          cache.put(event.request, clonedResponse);
        });
        return response;
      })
      .catch(() => {
        return caches.match(event.request);
      })
  );
});
```

در این مثال :

در رویداد fetch ابتدا سعی می کنیم منبع را از شبکه fetch کنیم.
اگر fetch موفقیت آمیز باشد، پاسخ را شبیه سازی کرده و آن را برای استفاده در حافظه پنهان ذخیره می کنیم، سپس پاسخ را برای ارائه محتوای شبکه برمی گردانیم.

اگر fetch شبکه ناموفق باشد (به دلیل آفلاین بودن)، نسخه ذخیره شده منبع درخواستی را ارائه می دهیم.


### Cash-Only Strategy

استراتژی Cache-Only در زمینه سرویس‌ورکر ها به یک استراتژی ذخیره‌سازی اشاره دارد که در آن سرویس‌کار تمام درخواست‌های شبکه را رهگیری می‌کند و پاسخ‌ها را مستقیماً از حافظه پنهان ارائه می‌کند. هیچ درخواست شبکه ای برای fetch کردن منابع جدید انجام نمی دهد و اگر منبع درخواستی در حافظه پنهان پیدا نشود، منجر به درخواست ناموفق می شود.

در اینجا نحوه عملکرد استراتژی Cache-Only آمده است:

1- Cashing Resources : هنگامی که Service Worker در ابتدا نصب یا فعال می شود، می توان آن را به گونه ای پیکربندی کرد که منابع خاصی مانند فایل های HTML، CSS، جاوا اسکریپت، تصاویر و غیره را pre-cash کند.

2- Intercepting Network Requests : هنگامی که یک صفحه درخواست شبکه می دهد، سرویس ورکر آن درخواست را رهگیری می کند. به جای ارسال درخواست به شبکه، کش را بررسی می کند تا ببیند آیا منبع درخواستی قبلاً ذخیره شده است یا خیر.

3- Serving from Cache: اگر منبع درخواستی در حافظه پنهان یافت شود، سرویس ورکر آن منبع ذخیره‌شده را مستقیماً به صفحه وب سرویس می‌دهد و شبکه را دور می‌زند.

4- Fallback for Uncached Resources: اگر منبع درخواستی در حافظه پنهان یافت نشود، سرویس ورکر درخواست شبکه برای واکشی منبع نخواهد کرد. در عوض، یک خطا یا یک پاسخ بازگشتی پیش‌فرض را برمی‌گرداند.

- استراتژی Cache-Only معمولاً برای asset هایی استفاده می شود که انتظار نمی رود به طور مکرر تغییر کنند و می توانند به طور ایمن برای مدت طولانی ذخیره شوند. این رویکرد برای سناریوهایی مناسب است که در آن اتصال به شبکه ضروری نیست یا در آن اولویت برای اطمینان از زمان‌های بارگذاری سریع و قابل اعتماد برای asset هایی است که قبلاً در حافظه پنهان هستند.
توجه به این نکته مهم است که استفاده از یک استراتژی سختگیرانه Cache-Only می‌تواند منجر به مشکلات احتمالی در هنگام استقرار به‌روزرسانی‌های برنامه شما شود، زیرا سرویس‌ورکر به سرویس‌دهی منابع ذخیره‌شده تا زمانی که حافظه پنهان صریحاً نامعتبر یا پاک شود، ادامه می‌دهد.
این استراتژی ممکن است برای سناریوهایی مانند برنامه‌های اول آفلاین مفید باشد، جایی که کاربران نیاز دارند حتی زمانی که آفلاین هستند به محتوای خاصی دسترسی داشته باشند، و انتظار می‌رود محتوا برای مدت معینی ثابت بماند.
هنگام پیاده‌سازی استراتژی‌های کش با سرویس ورکر ها، مهم است که نیازهای خاص برنامه، تجربه کاربر و تعادل مناسب بین کارایی ذخیره‌سازی و به‌روز نگه‌داشتن محتوا را در نظر بگیرید.


```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    caches.match(event.request).then(response => {
      return response || new Response('Resource not cached', { status: 404 });
    })
  );
});
```
- توضیحات اضافه شود



همانطور که از نام آن پیداست، استراتژی ذخیره سازی Network-Only ، شامل fetch  کردن منابع مستقیماً از شبکه بدون نیاز به مکانیزم های ذخیره سازی است. این استراتژی تضمین می‌کند که تازه‌ترین نسخه یک منبع همیشه از شبکه getch می‌شود و از هیچ نسخه کش استفاده نمی‌شود.
در اینجا نحوه عملکرد استراتژی Network-Only آمده است:

1- Request Resources : هنگامی که یک صفحه وب درخواستی برای یک منبع (به عنوان مثال، یک تصویر، یک فایل JSON یا یک نقطه پایانی API) ارائه می‌کند، سرویس‌ورکر درخواست شبکه را رهگیری می‌کند.

2- Fetch from Network : به جای اینکه ابتدا حافظه پنهان را بررسی کند، سرویس ورکر بلافاصله درخواست را به شبکه ارسال می کند و به مرورگر اجازه می دهد تا منبع را مستقیماً از سرور fetch کند.

3-  Response to Web Page: سپس پاسخ شبکه به صفحه وب برگردانده می‌شود و سرویس‌ورکر ممکن است پاسخ را بر اساس پیکربندی حافظه پنهان خود ذخیره کند، اما صفحه وب مستقیماً از هیچ نسخه ذخیره‌سازی شده استفاده نمی‌کند.

4-  Freshness Assurance : استراتژی فقط شبکه تضمین می کند که صفحه وب همیشه به روزترین نسخه منبع را دریافت می کند، که می تواند برای محتوای پویا یا منابعی که مرتباً تغییر می کنند بسیار مهم باشد.

استراتژی Network-Only در سناریوهایی که داده‌های real-time حیاتی هستند مفید است و ذخیره‌سازی حافظه پنهان می‌تواند مانع از ارائه جدیدترین اطلاعات شود. برای مثال، هنگام بارگیری داده‌های زنده از یک API یا محتوایی که اغلب به‌روزرسانی می‌شود، استفاده از استراتژی network-only می‌تواند از ارائه محتوای قدیمی از حافظه پنهان جلوگیری کند.

با این حال، توجه به این نکته مهم است که تنها اتکا به استراتژی Network-Only می تواند منجر به افزایش زمان بارگذاری شود، به خصوص اگر اتصال شبکه کند یا غیرقابل اعتماد باشد. این استراتژی ممکن است برای asset هایی که اغلب تغییر نمی‌کنند ایده‌آل نباشد و می‌تواند از ذخیره‌سازی محلی برای کاهش درخواست‌های شبکه و بهبود عملکرد بهره‌مند شود.
اجرای استراتژی network-only نسبتاً ساده است. شما نیازی به مدیریت صریح حافظه پنهان در سرویس‌ورکر ندارید، زیرا رفتار پیش‌فرض مرورگر این است که هنگام استفاده از این استراتژی، منابع را از شبکه fetch می‌کند بدون اینکه در حافظه پنهان ذخیره شود.

```javascript
self.addEventListener('fetch', event => {
  event.respondWith(
    fetch(event.request)
  );
});
```

- توضیحات اضافه شود

استراتژی ذخیره سازی Stale-While-Revalidate که با نام (SWR) نیز شناخته می شود، یک الگوی ذخیره سازی است که مزایای ارائه فوری محتوای کش شده را ترکیب می کند و همزمان حافظه پنهان را با محتوای تازه از شبکه در پس زمینه به روز می کند. . هدف این استراتژی بهبود عملکرد و تجربه کاربری برنامه های کاربردی وب با به حداقل رساندن تأثیر تأخیر شبکه بر روی کاربر است.

در اینجا نحوه عملکرد استراتژی Stale-While-Revalidate آورده شده است:

1- Request Resources: هنگامی که یک صفحه وب درخواستی برای یک منبع (به عنوان مثال، یک تصویر، یک فایل JSON یا یک نقطه پایانی API) ارائه می‌کند، سرویس‌ورکر درخواست شبکه را رهگیری می‌کند.

2- Check Cache: سرویس‌ورکر ابتدا بررسی می کند که آیا منبع درخواستی در حافظه پنهان موجود است یا خیر. اگر منبع پیدا شد ،منبع ذخیره شده بلافاصله به صفحه وب بازگردانده می شود و زمان پاسخگویی را بهبود می بخشد.

3- Fetch from Network (Revalidate):  به طور همزمان، سرویس‌ورکر یک درخواست شبکه را برای fetch  کردن همان منبع از شبکه آغاز می کند. این درخواست در پس‌زمینه، بدون تاخیر در تحویل محتوای ذخیره‌شده به صفحه وب انجام می‌شود.

4- Update Cache: هنگامی که پاسخ شبکه دریافت شد، سرویس‌ورکر حافظه پنهان را با محتوای تازه به روز می کند. این تضمین می کند که درخواست های بعدی برای همان منبع به روزترین نسخه را دریافت خواهند کرد.

5- Return Fresh Content: اگر منبع در حافظه پنهان یافت نشد یا محتوای ذخیره شده قدیمی بود، سرویس‌ورکر بلافاصله محتوای تازه دریافت شده از شبکه را به صفحه وب ارائه می‌کند.

با استفاده از استراتژی  Stale-While-Revalidate، برنامه های کاربردی وب می توانند با ارائه سریع محتوای کش شده و به روز نگه داشتن حافظه پنهان با آخرین منابع، یک تجربه کاربری یکپارچه را ارائه دهند. این به ویژه برای سناریوهایی مفید است که داده های real-time مهم هستند، اما پاسخگویی فوری نیز بسیار مهم است.
شایان ذکر است که اگرچه Stale-While-Revalidate می تواند عملکرد را بهبود بخشد، ایجاد تعادل بین تازگی و عملکرد ضروری است. استفاده بیش از حد از این استراتژی ممکن است منجر به درخواست های شبکه بیش از حد شود و به طور بالقوه بر تجربه کاربر تأثیر بگذارد، به خصوص اگر تأخیر شبکه زیاد باشد.
برای پیاده‌سازی استراتژی  Stale-While-Revalidate، باید مدیریت کش و درخواست‌های شبکه را در کد سرویس‌کار خود مدیریت کنید. سرویس ورکر باید تصمیم بگیرد که آیا محتوای کش را ارائه کند یا محتوای تازه را بر اساس در دسترس بودن حافظه پنهان و تازگی داده های ذخیره شده در حافظه پنهان ارائه دهد.
مانند هر استراتژی ذخیره سازی دیگر، در هنگام اجرای Stale-While-Revalidate، توجه دقیق به الزامات برنامه و انتظارات کاربر ضروری است.

به یاد داشته باشید که استراتژی‌های ذخیره‌سازی را می‌توان بر اساس موارد استفاده خاص شما تنظیم کرد. همچنین می‌توانید استراتژی‌های مختلف را برای انواع مختلف منابع برای دستیابی به عملکرد مطلوب و عملکرد آفلاین در برنامه وب خود ترکیب کنید.

## Handling Updates & Versioning 

مدیریت به‌روزرسانی‌ها و نسخه‌سازی برای کارکنان خدمات برای اطمینان از به‌روز ماندن برنامه وب شما و اینکه کاربران آخرین ویژگی‌ها و رفع اشکال‌ها را دریافت می‌کنند، مهم است. همچنین تضمین می کند که منابع ذخیره شده به درستی مدیریت می شوند و کش های قدیمی پاک می شوند. در اینجا نحوه مدیریت به‌روزرسانی‌ها و نسخه‌سازی برای سرویس ورکر آمده است:

- Versioning the Service Worker

1- Define a Version Number: هنگامی که برای اولین بار یک سرویس ورکر ایجاد می کنید، یک شماره نسخه به آن بدهید. این شماره نسخه باید هر بار که تغییراتی در اسکریپت Service Worker یا منابع ذخیره شده در حافظه پنهان ایجاد می کنید به روز شود.

```javascript
const CACHE_VERSION = 'v1';
```

2- Update the Service Worker File: هر زمان که تغییراتی در اسکریپت Service Worker ایجاد می کنید، باید شماره نسخه موجود در فایل را نیز به روز کنید

- Handling Updates

1-	Listen for the 'install' Event : هنگامی که نسخه جدیدی از سرویس ورکر ثبت می شود، مرورگر رویداد "نصب" را فعال می کند. این فرصت خوبی برای ذخیره منابع جدید یا به روز شده است.

```javascript
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_VERSION).then((cache) => {
      return cache.addAll([
        '/index.html',
        '/styles.css',
        '/app.js',
        // Add new or updated resources
      ]);
    })
  );
});
```

2- Listen for the 'activate' Event: پس از نصب یک سرویس ورکر جدید، مرورگر رویداد "فعال سازی" را فعال می کند. این مکان مناسبی برای پاکسازی کش های قدیمی از نسخه های قبلی است.

```javascript
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_VERSION) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```

- Update Prompt

1-	Listen for the 'message' Event : می توانید یک درخواست به روز رسانی را برای کاربران پیاده سازی کنید تا آنها را از در دسترس بودن نسخه جدید برنامه مطلع کنند. به رویداد message از client ،  listen کنید تا این درخواست را فعال کنید.

```javascript
self.addEventListener('message', (event) => {
  if (event.data === 'skipWaiting') {
    self.skipWaiting();
  }
});
```

2-	Trigger Update: در کد کلاینت خود (جاوا اسکریپت در صفحات وب شما اجرا می شود)، می توانید یک "پیام" به سرویس ورکر ارسال کنید تا از آن بخواهد به روز رسانی شود.

```javascript 
if (navigator.serviceWorker.controller) {
  navigator.serviceWorker.controller.postMessage('skipWaiting');
}
```


با دنبال کردن این مراحل، می‌توانید اطمینان حاصل کنید که سرویس‌ورکر شما هنگام انتشار نسخه‌های جدید برنامه وب خود، به‌درستی به‌روزرسانی می‌شود. این کمک می کند تا برنامه شما قابل اعتماد، ایمن و به روز نگه داشته شود


